queryOptions 사용 예제 규칙

UI / Feature 계층에서는 queryOptions 객체만 소비한다.
useQuery, prefetchQuery, ensureQueryData 모두 동일한 queryOptions를 사용한다.

Feature / UI에서 useQuery 사용 예제

queryKey, queryFn을 직접 정의하지 않는다.

반드시 queryOptions를 그대로 전달한다.

import { useSuspense } from "@tanstack/react-query";
import weatherQueryOption from "@/entities/weather/model/queryOption";

interface Props {
lat: number;
lon: number;
}

export const WeatherDetail = ({ lat, lon }: Props) => {
const { data, isLoading, isError } = useSuspense(
weatherQueryOption.weather({ lat, lon })
);

return (

<section>
<h2>{data.location.name}</h2>
<p>{data.current.temp_c}°C</p>
<p>{data.current.condition.text}</p>
</section>
);
};

queryOptions 사용 시 금지 사항

❌ useQuery({
queryKey: [...],
queryFn: () => fetch(...)
})

❌ useQuery({
queryKey: weatherQueryKeyFactory.detail(...),
queryFn: customFn
})

❌ useQuery({
queryKey: [...],
})

queryKey / queryFn을 UI에서 직접 정의하지 않는다.

반드시 entities 계층의 queryOptions를 재사용한다.

queryOptions 사용의 핵심 목적 (Cursor 참고용)

Query Key / Query Fn / 캐싱 정책을 단일 진실 공급원(Single Source of Truth) 으로 유지

UI는 “데이터를 어떻게 가져오는지”를 몰라도 된다.

API 변경 / 캐싱 정책 변경 시 entities 계층만 수정
